import math
import random
import numpy as np
import operator
rng = np.random.RandomState(43)
lst = list(np.random.randint(0,100, 10))
print(f'исходный лист {lst}')
def insertion(data):
    '''Возвращает отсортированный массив.
    Сортировка выполняется методом простой вставки
    хорошо справляется когда имеет дело с почти отсортированными массивами'''
    for i in range(len(data)):
        key = data[i] #key это переменная хранилище, которая хранит значение ячейки, в кот будет происходить сорировка
        j = i-1
        while data[j] > key and j >=0:
            data[j+1] = data[j]
            j -=1
            #мы на все время действия итерации сохраняем значение data[i], потому что если на
            # наши условия соблюдаются, то элемент массива с этим индексом перепишется и мы его потеряеv
            #поэтому когда мы произвели все замены в конце внутренней итерации мы
            #элемент на котором остановили
        data[j+1] = key #это волшебная строка, так как она возвращает значение
        # элементу, на котором закончилась сортировка.
print(insertion(lst))
print(math.sqrt(19**2 + 37**2)/2.54)

'''def binar_insertion(data:list) -> list:

    Здесь также значение крайнего элемента неотсортированного массива, который будем
    Вставлять в отсортированный массив сохраняем во временное хранилище.
    Затем запускаем цикл for c количеством итераций равным количеству элементов.
    тут мы запоминаем значение в Key и делаем еще две вещи
    Во первых переменная lo - которая выполняет роль нижней границы при поиске места вставки
    Во вторых переменная hi, которая как и в прошлой модификации выполняет выполняет роль
    элемента, который сравнивается с ключевым значением.
    дальше пишем условный цикл, для поиска места вставки, он выполняется до тех пор пока.
    нижняя граница меньше значения, с которым будет проводиться сравнение.
    То есть в первой итерации, когда i==0, а hi==-1, этот цикл не активируется.
    В теле этого цикла мы вводим еще одну переменную, которая является отражение индекса
    середины отсортированного массива.
    mid = нижняя граница + количество элементов в массиве//2
    если Значение в ключе меньше чем значение среднего элемента отсортированного массива
    значит индекса искомого места вставки равен индексу среднего элемента массива
    в противном случае индекс нижней границы принимает значение среднего элемента +1
    Цикл повторяется еще раз. До тех пор пока мы не найдем точный коэффициент hi
    Далее мы запускаем цикл for j (i(текущая итерация), индекс_нижняя_граница+1, -1(идем в обратном порядке))
    В теле этого цикла постепенно назначаем впередистоящему элементу значение прошлого.
    for i in range(1, len(data) - 1):
        key = data[i]
        lo, hi = 0, i - 1
        while lo < hi:
            mid = lo + (hi - lo) // 2
            if key < data[mid]:
                hi = mid
            else:
                lo = mid
        for j in range(i, lo + 1, -1):
            data[j] = data[j - 1]
        data[lo] = key
    return data
print(binar_insertion(lst))
for i in range(1,0,-1):
    print('rabotaet edinichnay iteraciya')
'''
def vybor(data:list) ->list:
    '''
    Так ну тут вроде все очень просто.
    У нас два цикла.
    Внешний цикл делает столько итераций сколько элементов
    Во внешнем цикле мы назначаем индекс по которому в данным момент идет итерация
    Соответственно индексом локального минимального или максимального элемента.
    Далее мы задаем внутренний цикл от индекса текущей индексации + 1 и до конца.
    То есть говоря проще мы проводим итерацию, по оставшимся элементам массива.
    На каждой внутренней итерации мы проверяем меньше ли значение элемента массива с данным индексом
    элемента с тем индексом, который мы определили на внешнем цикле.
    Если условие выполняется, то назначаем текущему индексу, как бы индекса минимального значения
    Если условие не выполняется, то след итерация.
    После того, как выполнится весь внутренний цикл, мы соответсвенно выполняем операцию
    взаимного присваивания элементу с индексом текущей итерации мы приравниванием элемент
    у которого получилось минимальное значение и наоборот.
    Таким образом после одной внешней итерации у нас точно определился минимум или максимум
    в зависимости от того в каком порядке мы решили выполнять сортировку.
    Столько разговоров а по факту все очень просто.
    '''
    for i in range(len(data)):
        min_index= i
        for j in range(i+1, len(data)):
            if data[j] < data [min_index]:
                min_index = j
        data[i],data[min_index] = data[min_index], data[i]
    return data

#функция, которая будет выполнять операцию
#поэлементного слияния-сортировки подмассивов
def merge_list(left,right):
    result_list = []
    i = 0
    j = 0
    # цикл пока не дойдем до конца первого или второго списка.
    while i<len(left) and j<len(right):
        if left[i] <= right[j]:
            result_list.append(left[i])
            i +=1
        else:
            result_list.append(right[j])
            j +=1
    # сложение оставшихся элементов в неотсортированных массивах
    result_list += left[i:] + right[j:]
    return result_list
# функция которая будет делить и сливать списки в общий отсортированный список
def split_and_merge_list(data):
    middle = len(data) //2
    left = data[:middle]
    right = data[middle:]

    if len(left)>1:
        left = split_and_merge_list(left)
    if len(right)>1:
        right = split_and_merge_list(right)

    return merge_list(left, right)

print(split_and_merge_list(lst))

